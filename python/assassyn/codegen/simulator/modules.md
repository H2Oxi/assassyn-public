# Module Generation

This module generates the simulation of each Assassyn [module](../../ir/module/),
including [pipeline stage](../../ir/module/module.py) and [downstream](../../ir/module/downstream.py).

## Exposed Interface

```python
def dump_modules(sys: SysBuilder, fd):
```

This function iterates over all the modules within the `sys`tem
to the given `fd`.

> TODO: All the memory related callbacks are currently a bad hack. Later implement them in a fundamental way.

This function instantiates `ElaborateModule`, which provides the key methods of dumping each module.

## Generated Module

Each generated module looks like below, which returns if this module is properly executed.
If the module successfully hits the end of the module, it returns `true`.
When it comes to a `wait_until` intrinsic, and the condition is not true,
it returns `false`.

This function will be exposed in `super::modules::*` and
invoked by `simulate_<module-name>` generated by [simulator.py](./simulator.py).

```rust
pub fn <module-name>(sim: &mut Simulator) -> bool {
```

Then it traverses all the components of within the module to dump the code accordingly
using the [visitor pattern](../../ir/visitor.py).


### Block

Block generation is done by `visit_block` of the visitor pattern.
- Conditional block is an if-statement.
- Cycled block is an `if sim.stamp / 100 == cycle`, as [simulator](./simulator.md)
  adopts a fixed point number for time stamp.

### Expression

Expression generation is done by `visit_expr` in visitor pattern.
The expression dumping are first dispatched to implementations in [_expr](./_expr/),
and then after dumping the expression itself, it also generates
the expression exposure --- if this expression is used by
an external module, write it to the `sim` context by generating

```rust
sim.<expr>_value = Some(value);
```

### IntImm

It provides helper function to generate the leaf node, immediate constants
in `visit_intimm`.